/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.docusign.iam.sdk;

import com.docusign.iam.sdk.models.components.TriggerWorkflow;
import com.docusign.iam.sdk.models.components.TriggerWorkflowSuccess;
import com.docusign.iam.sdk.models.components.WorkflowTriggerRequirementsSuccess;
import com.docusign.iam.sdk.models.components.WorkflowsListSuccess;
import com.docusign.iam.sdk.models.errors.APIException;
import com.docusign.iam.sdk.models.errors.Error;
import com.docusign.iam.sdk.models.operations.GetWorkflowTriggerRequirementsRequest;
import com.docusign.iam.sdk.models.operations.GetWorkflowTriggerRequirementsRequestBuilder;
import com.docusign.iam.sdk.models.operations.GetWorkflowTriggerRequirementsResponse;
import com.docusign.iam.sdk.models.operations.GetWorkflowsListRequest;
import com.docusign.iam.sdk.models.operations.GetWorkflowsListRequestBuilder;
import com.docusign.iam.sdk.models.operations.GetWorkflowsListResponse;
import com.docusign.iam.sdk.models.operations.SDKMethodInterfaces.*;
import com.docusign.iam.sdk.models.operations.TriggerWorkflowRequest;
import com.docusign.iam.sdk.models.operations.TriggerWorkflowRequestBuilder;
import com.docusign.iam.sdk.models.operations.TriggerWorkflowResponse;
import com.docusign.iam.sdk.utils.BackoffStrategy;
import com.docusign.iam.sdk.utils.HTTPClient;
import com.docusign.iam.sdk.utils.HTTPRequest;
import com.docusign.iam.sdk.utils.Hook.AfterErrorContextImpl;
import com.docusign.iam.sdk.utils.Hook.AfterSuccessContextImpl;
import com.docusign.iam.sdk.utils.Hook.BeforeRequestContextImpl;
import com.docusign.iam.sdk.utils.Options;
import com.docusign.iam.sdk.utils.Retries.NonRetryableException;
import com.docusign.iam.sdk.utils.Retries;
import com.docusign.iam.sdk.utils.RetryConfig;
import com.docusign.iam.sdk.utils.SerializedBody;
import com.docusign.iam.sdk.utils.Utils.JsonShape;
import com.docusign.iam.sdk.utils.Utils;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Exception;
import java.lang.Object;
import java.lang.String;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.TimeUnit;

public class Workflows implements
            MethodCallGetWorkflowsList,
            MethodCallGetWorkflowTriggerRequirements,
            MethodCallTriggerWorkflow {

    private final SDKConfiguration sdkConfiguration;

    Workflows(SDKConfiguration sdkConfiguration) {
        this.sdkConfiguration = sdkConfiguration;
    }

    /**
     * Retrieve a list of available Maestro workflows
     * 
     * <p>This operation retrieves a list of all available Maestro workflows. It returns basic information
     * about each workflow, including its unique identifier (`id`), name, description, and the input
     * schema required to trigger the workflow.
     * 
     * <p>The response provides key details that help users identify which workflows are available
     * and understand the input requirements for triggering each one. Each workflow entry also includes
     * metadata, such as when it was created, last modified, and by whom.
     * 
     * <p>This operation is useful for obtaining an overview of all workflows within the system, helping
     * users and systems know what workflows are defined, what inputs they require, and how they can
     * be triggered.
     * 
     * <p>### Use Cases:
     * - Listing all available workflows in a system for manual or automated workflow initiation.
     * - Reviewing the input requirements for a workflow before triggering it programmatically.
     * - Gathering basic metadata about workflows for auditing, logging, or reporting purposes.
     * 
     * <p>### Key Features:
     * - **Comprehensive Workflow Overview**: Provides a full list of workflows, giving visibility
     * 
     * <p>  into all the automated processes available within the Maestro platform.
     * - **Input Schema Information**: Each workflow includes its trigger input schema, showing
     * 
     * <p>  what data must be provided when triggering the workflow.
     * - **Metadata for Tracking**: Useful metadata like creation time, last modification date,
     * 
     * <p>  and user details are included to support tracking and auditing workflows.
     * - **Future-Proof**: The operation is designed to be expandable as more workflows are added
     * 
     * <p>  or the platform grows, ensuring scalability in the workflow management process.
     * 
     * @return The call builder
     */
    public GetWorkflowsListRequestBuilder getWorkflowsList() {
        return new GetWorkflowsListRequestBuilder(this);
    }

    /**
     * Retrieve a list of available Maestro workflows
     * 
     * <p>This operation retrieves a list of all available Maestro workflows. It returns basic information
     * about each workflow, including its unique identifier (`id`), name, description, and the input
     * schema required to trigger the workflow.
     * 
     * <p>The response provides key details that help users identify which workflows are available
     * and understand the input requirements for triggering each one. Each workflow entry also includes
     * metadata, such as when it was created, last modified, and by whom.
     * 
     * <p>This operation is useful for obtaining an overview of all workflows within the system, helping
     * users and systems know what workflows are defined, what inputs they require, and how they can
     * be triggered.
     * 
     * <p>### Use Cases:
     * - Listing all available workflows in a system for manual or automated workflow initiation.
     * - Reviewing the input requirements for a workflow before triggering it programmatically.
     * - Gathering basic metadata about workflows for auditing, logging, or reporting purposes.
     * 
     * <p>### Key Features:
     * - **Comprehensive Workflow Overview**: Provides a full list of workflows, giving visibility
     * 
     * <p>  into all the automated processes available within the Maestro platform.
     * - **Input Schema Information**: Each workflow includes its trigger input schema, showing
     * 
     * <p>  what data must be provided when triggering the workflow.
     * - **Metadata for Tracking**: Useful metadata like creation time, last modification date,
     * 
     * <p>  and user details are included to support tracking and auditing workflows.
     * - **Future-Proof**: The operation is designed to be expandable as more workflows are added
     * 
     * <p>  or the platform grows, ensuring scalability in the workflow management process.
     * 
     * @param accountId The unique identifier of the account.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public GetWorkflowsListResponse getWorkflowsList(
            String accountId) throws Exception {
        return getWorkflowsList(accountId, Optional.empty());
    }
    
    /**
     * Retrieve a list of available Maestro workflows
     * 
     * <p>This operation retrieves a list of all available Maestro workflows. It returns basic information
     * about each workflow, including its unique identifier (`id`), name, description, and the input
     * schema required to trigger the workflow.
     * 
     * <p>The response provides key details that help users identify which workflows are available
     * and understand the input requirements for triggering each one. Each workflow entry also includes
     * metadata, such as when it was created, last modified, and by whom.
     * 
     * <p>This operation is useful for obtaining an overview of all workflows within the system, helping
     * users and systems know what workflows are defined, what inputs they require, and how they can
     * be triggered.
     * 
     * <p>### Use Cases:
     * - Listing all available workflows in a system for manual or automated workflow initiation.
     * - Reviewing the input requirements for a workflow before triggering it programmatically.
     * - Gathering basic metadata about workflows for auditing, logging, or reporting purposes.
     * 
     * <p>### Key Features:
     * - **Comprehensive Workflow Overview**: Provides a full list of workflows, giving visibility
     * 
     * <p>  into all the automated processes available within the Maestro platform.
     * - **Input Schema Information**: Each workflow includes its trigger input schema, showing
     * 
     * <p>  what data must be provided when triggering the workflow.
     * - **Metadata for Tracking**: Useful metadata like creation time, last modification date,
     * 
     * <p>  and user details are included to support tracking and auditing workflows.
     * - **Future-Proof**: The operation is designed to be expandable as more workflows are added
     * 
     * <p>  or the platform grows, ensuring scalability in the workflow management process.
     * 
     * @param accountId The unique identifier of the account.
     * @param options additional options
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public GetWorkflowsListResponse getWorkflowsList(
            String accountId,
            Optional<Options> options) throws Exception {

        if (options.isPresent()) {
          options.get().validate(Arrays.asList(Options.Option.RETRY_CONFIG));
        }
        GetWorkflowsListRequest request =
            GetWorkflowsListRequest
                .builder()
                .accountId(accountId)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl();
        String _url = Utils.generateURL(
                GetWorkflowsListRequest.class,
                _baseUrl,
                "/accounts/{accountId}/workflows",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "GET");
        _req.addHeader("Accept", "application/json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        
        Optional<SecuritySource> _hookSecuritySource = Optional.of(this.sdkConfiguration.securitySource());
        Utils.configureSecurity(_req,  
                this.sdkConfiguration.securitySource().getSecurity());
        HTTPClient _client = this.sdkConfiguration.client();
        HTTPRequest _finalReq = _req;
        RetryConfig _retryConfig;
        if (options.isPresent() && options.get().retryConfig().isPresent()) {
            _retryConfig = options.get().retryConfig().get();
        } else if (this.sdkConfiguration.retryConfig().isPresent()) {
            _retryConfig = this.sdkConfiguration.retryConfig().get();
        } else {
            _retryConfig = RetryConfig.builder()
                .backoff(BackoffStrategy.builder()
                            .initialInterval(500, TimeUnit.MILLISECONDS)
                            .maxInterval(5000, TimeUnit.MILLISECONDS)
                            .baseFactor((double)(1.5))
                            .maxElapsedTime(30000, TimeUnit.MILLISECONDS)
                            .retryConnectError(true)
                            .build())
                .build();
        }
        List<String> _statusCodes = new ArrayList<>();
        _statusCodes.add("5XX");
        _statusCodes.add("429");
        Retries _retries = Retries.builder()
            .action(() -> {
                HttpRequest _r = null;
                try {
                    _r = sdkConfiguration.hooks()
                        .beforeRequest(
                            new BeforeRequestContextImpl(
                                this.sdkConfiguration,
                                _baseUrl,
                                "GetWorkflowsList", 
                                Optional.of(List.of()), 
                                _hookSecuritySource),
                            _finalReq.build());
                } catch (Exception _e) {
                    throw new NonRetryableException(_e);
                }
                try {
                    return _client.send(_r);
                } catch (Exception _e) {
                    return sdkConfiguration.hooks()
                        .afterError(
                            new AfterErrorContextImpl(
                                this.sdkConfiguration,
                                _baseUrl,
                                "GetWorkflowsList",
                                 Optional.of(List.of()),
                                 _hookSecuritySource), 
                            Optional.empty(),
                            Optional.of(_e));
                }
            })
            .retryConfig(_retryConfig)
            .statusCodes(_statusCodes)
            .build();
        HttpResponse<InputStream> _httpRes = sdkConfiguration.hooks()
                 .afterSuccess(
                     new AfterSuccessContextImpl(
                         this.sdkConfiguration,
                         _baseUrl,
                         "GetWorkflowsList", 
                         Optional.of(List.of()), 
                         _hookSecuritySource),
                     _retries.run());
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        GetWorkflowsListResponse.Builder _resBuilder = 
            GetWorkflowsListResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        GetWorkflowsListResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                WorkflowsListSuccess _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<WorkflowsListSuccess>() {});
                _res.withWorkflowsListSuccess(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "401", "403", "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                Error _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<Error>() {});
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "500")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                Error _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<Error>() {});
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }


    /**
     * Retrieve trigger requirements for a specific Maestro workflow
     * 
     * <p>This operation retrieves the configuration and input requirements necessary to trigger a specific
     * Maestro workflow. It provides detailed information about the `trigger_event_type`, such as HTTP
     * or other supported types, and specifies the required input schema, including field names, data types,
     * and any default values.
     * 
     * <p>This information is essential for understanding the data and parameters required to initiate the
     * workflow. It enables developers to prepare the necessary inputs and configuration before triggering
     * the workflow instance, ensuring seamless execution and compliance with workflow requirements.
     * 
     * <p>### Use Cases:
     * - Identifying the required input fields and their data types to successfully trigger the workflow.
     * - Reviewing the trigger configuration for validation and compliance with expected input.
     * - Preparing and validating data in advance of triggering the workflow, minimizing runtime errors.
     * 
     * <p>### Key Features:
     * - **Detailed Trigger Input Requirements**: Provides an exhaustive schema of required fields,
     * 
     * <p>  their data types, and optional default values for easy reference and data validation.
     * - **Trigger Event Type Information**: Specifies the type of event required to initiate the workflow
     * 
     * <p>  (e.g., HTTP), helping developers configure their systems to invoke the workflow appropriately.
     * - **Configurable for Custom Triggers**: Suitable for custom configurations, enabling flexibility
     * 
     * <p>  in how workflows can be triggered according to system needs.
     * 
     * @return The call builder
     */
    public GetWorkflowTriggerRequirementsRequestBuilder getWorkflowTriggerRequirements() {
        return new GetWorkflowTriggerRequirementsRequestBuilder(this);
    }

    /**
     * Retrieve trigger requirements for a specific Maestro workflow
     * 
     * <p>This operation retrieves the configuration and input requirements necessary to trigger a specific
     * Maestro workflow. It provides detailed information about the `trigger_event_type`, such as HTTP
     * or other supported types, and specifies the required input schema, including field names, data types,
     * and any default values.
     * 
     * <p>This information is essential for understanding the data and parameters required to initiate the
     * workflow. It enables developers to prepare the necessary inputs and configuration before triggering
     * the workflow instance, ensuring seamless execution and compliance with workflow requirements.
     * 
     * <p>### Use Cases:
     * - Identifying the required input fields and their data types to successfully trigger the workflow.
     * - Reviewing the trigger configuration for validation and compliance with expected input.
     * - Preparing and validating data in advance of triggering the workflow, minimizing runtime errors.
     * 
     * <p>### Key Features:
     * - **Detailed Trigger Input Requirements**: Provides an exhaustive schema of required fields,
     * 
     * <p>  their data types, and optional default values for easy reference and data validation.
     * - **Trigger Event Type Information**: Specifies the type of event required to initiate the workflow
     * 
     * <p>  (e.g., HTTP), helping developers configure their systems to invoke the workflow appropriately.
     * - **Configurable for Custom Triggers**: Suitable for custom configurations, enabling flexibility
     * 
     * <p>  in how workflows can be triggered according to system needs.
     * 
     * @param accountId The unique identifier of the account.
     * @param workflowId The unique identifier of the workflow.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public GetWorkflowTriggerRequirementsResponse getWorkflowTriggerRequirements(
            String accountId,
            String workflowId) throws Exception {
        return getWorkflowTriggerRequirements(accountId, workflowId, Optional.empty());
    }
    
    /**
     * Retrieve trigger requirements for a specific Maestro workflow
     * 
     * <p>This operation retrieves the configuration and input requirements necessary to trigger a specific
     * Maestro workflow. It provides detailed information about the `trigger_event_type`, such as HTTP
     * or other supported types, and specifies the required input schema, including field names, data types,
     * and any default values.
     * 
     * <p>This information is essential for understanding the data and parameters required to initiate the
     * workflow. It enables developers to prepare the necessary inputs and configuration before triggering
     * the workflow instance, ensuring seamless execution and compliance with workflow requirements.
     * 
     * <p>### Use Cases:
     * - Identifying the required input fields and their data types to successfully trigger the workflow.
     * - Reviewing the trigger configuration for validation and compliance with expected input.
     * - Preparing and validating data in advance of triggering the workflow, minimizing runtime errors.
     * 
     * <p>### Key Features:
     * - **Detailed Trigger Input Requirements**: Provides an exhaustive schema of required fields,
     * 
     * <p>  their data types, and optional default values for easy reference and data validation.
     * - **Trigger Event Type Information**: Specifies the type of event required to initiate the workflow
     * 
     * <p>  (e.g., HTTP), helping developers configure their systems to invoke the workflow appropriately.
     * - **Configurable for Custom Triggers**: Suitable for custom configurations, enabling flexibility
     * 
     * <p>  in how workflows can be triggered according to system needs.
     * 
     * @param accountId The unique identifier of the account.
     * @param workflowId The unique identifier of the workflow.
     * @param options additional options
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public GetWorkflowTriggerRequirementsResponse getWorkflowTriggerRequirements(
            String accountId,
            String workflowId,
            Optional<Options> options) throws Exception {

        if (options.isPresent()) {
          options.get().validate(Arrays.asList(Options.Option.RETRY_CONFIG));
        }
        GetWorkflowTriggerRequirementsRequest request =
            GetWorkflowTriggerRequirementsRequest
                .builder()
                .accountId(accountId)
                .workflowId(workflowId)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl();
        String _url = Utils.generateURL(
                GetWorkflowTriggerRequirementsRequest.class,
                _baseUrl,
                "/accounts/{accountId}/workflows/{workflowId}/trigger-requirements",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "GET");
        _req.addHeader("Accept", "application/json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        
        Optional<SecuritySource> _hookSecuritySource = Optional.of(this.sdkConfiguration.securitySource());
        Utils.configureSecurity(_req,  
                this.sdkConfiguration.securitySource().getSecurity());
        HTTPClient _client = this.sdkConfiguration.client();
        HTTPRequest _finalReq = _req;
        RetryConfig _retryConfig;
        if (options.isPresent() && options.get().retryConfig().isPresent()) {
            _retryConfig = options.get().retryConfig().get();
        } else if (this.sdkConfiguration.retryConfig().isPresent()) {
            _retryConfig = this.sdkConfiguration.retryConfig().get();
        } else {
            _retryConfig = RetryConfig.builder()
                .backoff(BackoffStrategy.builder()
                            .initialInterval(500, TimeUnit.MILLISECONDS)
                            .maxInterval(5000, TimeUnit.MILLISECONDS)
                            .baseFactor((double)(1.5))
                            .maxElapsedTime(30000, TimeUnit.MILLISECONDS)
                            .retryConnectError(true)
                            .build())
                .build();
        }
        List<String> _statusCodes = new ArrayList<>();
        _statusCodes.add("5XX");
        _statusCodes.add("429");
        Retries _retries = Retries.builder()
            .action(() -> {
                HttpRequest _r = null;
                try {
                    _r = sdkConfiguration.hooks()
                        .beforeRequest(
                            new BeforeRequestContextImpl(
                                this.sdkConfiguration,
                                _baseUrl,
                                "GetWorkflowTriggerRequirements", 
                                Optional.of(List.of()), 
                                _hookSecuritySource),
                            _finalReq.build());
                } catch (Exception _e) {
                    throw new NonRetryableException(_e);
                }
                try {
                    return _client.send(_r);
                } catch (Exception _e) {
                    return sdkConfiguration.hooks()
                        .afterError(
                            new AfterErrorContextImpl(
                                this.sdkConfiguration,
                                _baseUrl,
                                "GetWorkflowTriggerRequirements",
                                 Optional.of(List.of()),
                                 _hookSecuritySource), 
                            Optional.empty(),
                            Optional.of(_e));
                }
            })
            .retryConfig(_retryConfig)
            .statusCodes(_statusCodes)
            .build();
        HttpResponse<InputStream> _httpRes = sdkConfiguration.hooks()
                 .afterSuccess(
                     new AfterSuccessContextImpl(
                         this.sdkConfiguration,
                         _baseUrl,
                         "GetWorkflowTriggerRequirements", 
                         Optional.of(List.of()), 
                         _hookSecuritySource),
                     _retries.run());
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        GetWorkflowTriggerRequirementsResponse.Builder _resBuilder = 
            GetWorkflowTriggerRequirementsResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        GetWorkflowTriggerRequirementsResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                WorkflowTriggerRequirementsSuccess _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<WorkflowTriggerRequirementsSuccess>() {});
                _res.withWorkflowTriggerRequirementsSuccess(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "401", "403", "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                Error _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<Error>() {});
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "500")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                Error _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<Error>() {});
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }


    /**
     * Trigger a new instance of a Maestro workflow
     * 
     * <p>This operation triggers a new instance of a specified Maestro workflow. When invoked,
     * the workflow is started based on the provided input data, and the workflow instance
     * begins executing according to its defined logic and configuration.
     * 
     * <p>The request requires an `instance_name` and any input data necessary to start the workflow,
     * as described by the workflow's `trigger_input_schema`. The `instance_name` is a user-defined
     * label for tracking the workflow run, while the input data fields should match the schema defined
     * in the workflow.
     * 
     * <p>The operation is event-driven and typically triggered by an external HTTP event or system call,
     * allowing for the automatic execution of complex processes that span multiple systems or components.
     * 
     * <p>Upon successful execution, the response returns the unique identifier (`id`) for the newly
     * created workflow instance, along with a URL (`workflow_instance_url`) that can be used to
     * interact with or track the running instance.
     * 
     * <p>### Use Cases:
     * - Automating user registration workflows where input fields like `name` and `email` are provided.
     * - Processing financial transactions where details such as `amount` and `currency` are required.
     * - Sending notifications based on user interactions in other systems.
     * 
     * <p>### Key Features:
     * - **Automated Execution**: Once triggered, the workflow runs until a step requires manual intervention.
     * - **Input-Driven**: Workflow execution is based on the provided input data, which is validated
     * 
     * <p>  against the workflow's input schema.
     * - **Real-Time Triggering**: Designed to be invoked as part of an event-driven architecture,
     * 
     * <p>  allowing for workflows to respond to external events.
     * - **Tracking and Interaction**: The response includes a URL that allows users to check the status
     * 
     * <p>  of the workflow instance or take further actions while it runs.
     * 
     * @return The call builder
     */
    public TriggerWorkflowRequestBuilder triggerWorkflow() {
        return new TriggerWorkflowRequestBuilder(this);
    }

    /**
     * Trigger a new instance of a Maestro workflow
     * 
     * <p>This operation triggers a new instance of a specified Maestro workflow. When invoked,
     * the workflow is started based on the provided input data, and the workflow instance
     * begins executing according to its defined logic and configuration.
     * 
     * <p>The request requires an `instance_name` and any input data necessary to start the workflow,
     * as described by the workflow's `trigger_input_schema`. The `instance_name` is a user-defined
     * label for tracking the workflow run, while the input data fields should match the schema defined
     * in the workflow.
     * 
     * <p>The operation is event-driven and typically triggered by an external HTTP event or system call,
     * allowing for the automatic execution of complex processes that span multiple systems or components.
     * 
     * <p>Upon successful execution, the response returns the unique identifier (`id`) for the newly
     * created workflow instance, along with a URL (`workflow_instance_url`) that can be used to
     * interact with or track the running instance.
     * 
     * <p>### Use Cases:
     * - Automating user registration workflows where input fields like `name` and `email` are provided.
     * - Processing financial transactions where details such as `amount` and `currency` are required.
     * - Sending notifications based on user interactions in other systems.
     * 
     * <p>### Key Features:
     * - **Automated Execution**: Once triggered, the workflow runs until a step requires manual intervention.
     * - **Input-Driven**: Workflow execution is based on the provided input data, which is validated
     * 
     * <p>  against the workflow's input schema.
     * - **Real-Time Triggering**: Designed to be invoked as part of an event-driven architecture,
     * 
     * <p>  allowing for workflows to respond to external events.
     * - **Tracking and Interaction**: The response includes a URL that allows users to check the status
     * 
     * <p>  of the workflow instance or take further actions while it runs.
     * 
     * @param accountId The unique identifier of the account.
     * @param workflowId The unique identifier of the workflow.
     * @param triggerWorkflow The input information needed to trigger a new instance of a Maestro workflow.
     *         This request body contains the metadata to describe the instance being created,
     *         along with the input data required to trigger the workflow.
     *         
     *         - `instance_name` provides a user-defined name for the workflow instance.
     *         - `trigger_inputs` contains the key-value pairs corresponding to the inputs required by the workflow, as described in the `trigger_input_schema` from the workflow definition.
     *         
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public TriggerWorkflowResponse triggerWorkflow(
            String accountId,
            String workflowId,
            TriggerWorkflow triggerWorkflow) throws Exception {
        return triggerWorkflow(accountId, workflowId, triggerWorkflow, Optional.empty());
    }
    
    /**
     * Trigger a new instance of a Maestro workflow
     * 
     * <p>This operation triggers a new instance of a specified Maestro workflow. When invoked,
     * the workflow is started based on the provided input data, and the workflow instance
     * begins executing according to its defined logic and configuration.
     * 
     * <p>The request requires an `instance_name` and any input data necessary to start the workflow,
     * as described by the workflow's `trigger_input_schema`. The `instance_name` is a user-defined
     * label for tracking the workflow run, while the input data fields should match the schema defined
     * in the workflow.
     * 
     * <p>The operation is event-driven and typically triggered by an external HTTP event or system call,
     * allowing for the automatic execution of complex processes that span multiple systems or components.
     * 
     * <p>Upon successful execution, the response returns the unique identifier (`id`) for the newly
     * created workflow instance, along with a URL (`workflow_instance_url`) that can be used to
     * interact with or track the running instance.
     * 
     * <p>### Use Cases:
     * - Automating user registration workflows where input fields like `name` and `email` are provided.
     * - Processing financial transactions where details such as `amount` and `currency` are required.
     * - Sending notifications based on user interactions in other systems.
     * 
     * <p>### Key Features:
     * - **Automated Execution**: Once triggered, the workflow runs until a step requires manual intervention.
     * - **Input-Driven**: Workflow execution is based on the provided input data, which is validated
     * 
     * <p>  against the workflow's input schema.
     * - **Real-Time Triggering**: Designed to be invoked as part of an event-driven architecture,
     * 
     * <p>  allowing for workflows to respond to external events.
     * - **Tracking and Interaction**: The response includes a URL that allows users to check the status
     * 
     * <p>  of the workflow instance or take further actions while it runs.
     * 
     * @param accountId The unique identifier of the account.
     * @param workflowId The unique identifier of the workflow.
     * @param triggerWorkflow The input information needed to trigger a new instance of a Maestro workflow.
     *         This request body contains the metadata to describe the instance being created,
     *         along with the input data required to trigger the workflow.
     *         
     *         - `instance_name` provides a user-defined name for the workflow instance.
     *         - `trigger_inputs` contains the key-value pairs corresponding to the inputs required by the workflow, as described in the `trigger_input_schema` from the workflow definition.
     *         
     * @param options additional options
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public TriggerWorkflowResponse triggerWorkflow(
            String accountId,
            String workflowId,
            TriggerWorkflow triggerWorkflow,
            Optional<Options> options) throws Exception {

        if (options.isPresent()) {
          options.get().validate(Arrays.asList(Options.Option.RETRY_CONFIG));
        }
        TriggerWorkflowRequest request =
            TriggerWorkflowRequest
                .builder()
                .accountId(accountId)
                .workflowId(workflowId)
                .triggerWorkflow(triggerWorkflow)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl();
        String _url = Utils.generateURL(
                TriggerWorkflowRequest.class,
                _baseUrl,
                "/accounts/{accountId}/workflows/{workflowId}/actions/trigger",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "POST");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "triggerWorkflow",
                "json",
                false);
        if (_serializedRequestBody == null) {
            throw new Exception("Request body is required");
        }
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        
        Optional<SecuritySource> _hookSecuritySource = Optional.of(this.sdkConfiguration.securitySource());
        Utils.configureSecurity(_req,  
                this.sdkConfiguration.securitySource().getSecurity());
        HTTPClient _client = this.sdkConfiguration.client();
        HTTPRequest _finalReq = _req;
        RetryConfig _retryConfig;
        if (options.isPresent() && options.get().retryConfig().isPresent()) {
            _retryConfig = options.get().retryConfig().get();
        } else if (this.sdkConfiguration.retryConfig().isPresent()) {
            _retryConfig = this.sdkConfiguration.retryConfig().get();
        } else {
            _retryConfig = RetryConfig.builder()
                .backoff(BackoffStrategy.builder()
                            .initialInterval(500, TimeUnit.MILLISECONDS)
                            .maxInterval(5000, TimeUnit.MILLISECONDS)
                            .baseFactor((double)(1.5))
                            .maxElapsedTime(30000, TimeUnit.MILLISECONDS)
                            .retryConnectError(true)
                            .build())
                .build();
        }
        List<String> _statusCodes = new ArrayList<>();
        _statusCodes.add("5XX");
        _statusCodes.add("429");
        Retries _retries = Retries.builder()
            .action(() -> {
                HttpRequest _r = null;
                try {
                    _r = sdkConfiguration.hooks()
                        .beforeRequest(
                            new BeforeRequestContextImpl(
                                this.sdkConfiguration,
                                _baseUrl,
                                "TriggerWorkflow", 
                                Optional.of(List.of()), 
                                _hookSecuritySource),
                            _finalReq.build());
                } catch (Exception _e) {
                    throw new NonRetryableException(_e);
                }
                try {
                    return _client.send(_r);
                } catch (Exception _e) {
                    return sdkConfiguration.hooks()
                        .afterError(
                            new AfterErrorContextImpl(
                                this.sdkConfiguration,
                                _baseUrl,
                                "TriggerWorkflow",
                                 Optional.of(List.of()),
                                 _hookSecuritySource), 
                            Optional.empty(),
                            Optional.of(_e));
                }
            })
            .retryConfig(_retryConfig)
            .statusCodes(_statusCodes)
            .build();
        HttpResponse<InputStream> _httpRes = sdkConfiguration.hooks()
                 .afterSuccess(
                     new AfterSuccessContextImpl(
                         this.sdkConfiguration,
                         _baseUrl,
                         "TriggerWorkflow", 
                         Optional.of(List.of()), 
                         _hookSecuritySource),
                     _retries.run());
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        TriggerWorkflowResponse.Builder _resBuilder = 
            TriggerWorkflowResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        TriggerWorkflowResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "201")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                TriggerWorkflowSuccess _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<TriggerWorkflowSuccess>() {});
                _res.withTriggerWorkflowSuccess(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "401", "403", "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                Error _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<Error>() {});
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "500")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                Error _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<Error>() {});
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }

}
